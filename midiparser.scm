(define pif 0);(input-port-byte-position (current-input-port))) ;place in file
(define (r)
  (write (list (peek) (peek-char))) (newline)
  (set! pif (+ 1 pif))
  (char->integer (read-char)))
(define (peek)
  (char->integer (peek-char)))
(define (read-list n)
  (if (zero? n)
    '()
    (cons (r) (read-list (- n 1)))))

(define (combine-loop a b absa absb)
  (define (addvarlen l n)
    (if (null? l)
      '()
      (append (list (cons (+ n (caar l))
                    (cdar l)))
              (cdr l))))
  (if (null? a)
    (addvarlen b (- absb absa))
    (if (null? b)
      (addvarlen a (- absa absb))
      (if (> (+ absa (caar a)) (+ absb (caar b)))
        (combine-loop b a absb absa)
        (let ((diff (if (> absb absa)
                      (- (+ absa (caar a)) absb)
                      (caar a))))
          (append (list (cons diff (cdar a)))
                  (combine-loop b
                                (cdr a)
                                absb
                                (+ absa (caar a)))))))))
(define (combine a b) (combine-loop a b 0 0))

(define (readvarlen)
  (if (zero? (fxand #x80 (peek)))
    (r)
    (+ (* #x80 (fxand #x7f (r)))
       (readvarlen))))

(define (motor16->num numa)
  (+ (* #x100 (car numa))
     (cadr numa)))
(define (read-motor16)
  (motor16->num (read-list 2)))
(define (motor32->num numa)
  (+ (motor16->num (cddr numa))
     (* #x10000 (motor16->num (list (car numa) (cadr numa))))))
(define (read-motor32)
  (motor32->num (read-list 4)))


(define (intel16->num numa)
  (+ (* #x100 (cadr numa))
     (car numa)))
(define (intel32->num numa)
  (+ (* #x10000 (intel16->num (cddr numa)))
     (intel16->num (list (car numa) (cadr numa)))))
(define (read-intel32)
  (intel32->num (read-list 4)))

(define (match l)
  (if (null? l)
    '()
    (if (eq? (car l) (peek))
      (begin
        (r)
        (match (cdr l)))
      (write (list "Expected " l "got " (peek) ".\n")))))

(define (meta-event)
  (case (r)
    ((#x2F) (list 'eot (r)))))

(define (event-data type)
  (case type
    ((#x3) (list 'vol
                 'value (r)))
    ((#x8) (list 'off
                 'note (r)
                 'velocity (r)))
    ((#x9) (list 'on
                 'note (r)
                 'velocity (r)))
    ((#xA) (list 'pressure
                 'note (r)
                 'value (r)))
    ((#xB) (list 'control (r)
                 'value (r)))
    ((#xC) (list 'program (r)))
    ((#xD) (list 'pressure (r)))
    ((#xE) (list 'pitch-bend (r) (r)))
    ((#xF) (list 'meta (meta-event)))
    (else (display (list "Unexpected event type " type ".\n")))))

(define (event)
  (let ((delta (readvarlen))
        (b (r)))
    (let ((type (fxarithmetic-shift-right b 4))
          (channel (fxand #xf b)))
      (list delta
            channel
            (event-data type)))))

(define endoftrack (list 0 #xf '(meta (eot 0))))
(define (track)
  (define (loop)
    (let ((e (event)))
      (if (equal? e endoftrack)
        (list e)
        ;(begin (write e) (newline)
        (append (list e)
              (loop)))))

  (let ((eotpos (+ (chunk "MTrk") pif))
        (data (loop)))
    (if (= eotpos pif)
      data
      'Error3)))

(define (tracks ntracks)
  (if (zero? ntracks)
    '()
    (combine (track)
             (tracks (- ntracks 1)))))

(define (string->ints s)
  (map char->integer (string->list s)))


(define (read-table file)
  (define t (make-table))
  (define port (open-input-file file))
  (define (read-p p)
    (if (eof? (peek-char port))
      '()
      (if (not (p (peek-char port)))
        '()
        (cons (read-char port)
              (read-p p)))))
  (define (number? char)
    (and (char<=? #\0 char)
         (char>=? #\9 char)))
  (define (eof? char)
    (eq? #!eof char))
  (define (newline? char)
    (or (eof? char)
        (char=? char #\newline)))
  (define (white? char)
    (or (char=? char #\space)
        (char=? char (integer->char 9))))
  (define (char->digit char)
    (- (char->integer char)
       (char->integer #\0)))
  (define (list->number l)
    (if (null? l)
      '()
      (if (null? (cdr l))
        (char->digit (car l))
        (+ (* 10 (char->digit (car l)))
           (list->number (cdr l))))))
  (define (read-number)
    (list->number (read-p number?)))
  (define (loop)
    (if (not (eof? (peek-char port)))
      (let ((channel (read-number))
            (white1  (read-p white?))
            (note    (read-number))
            (white2  (read-p white?))
            (data    (list->string (read-p number?)))
            (white3  (read-p newline?)))
        (table-set! t (list channel note) data)
        (loop))))
  (loop)
  (close-port port)
  t)

(define format 0)
(define numtracks 0)
(define divisions 0)
(define tempo (* (/ (/ 120 60) 4) 1000000))
(define (chunk name)
  (if (null? (match (string->ints name)))
    (read-motor32)
    (display (list "Expected " name ".\n"))))
(define (header)
  (chunk "MThd")
  (set! format    (read-motor16))
  (set! numtracks (read-motor16))
  (set! divisions (read-motor16)))

(define (midifile)
  (header)
;  (write (list format numtracks divisions)) (newline)
  (tracks numtracks))

(define config-table (make-table))
(define (make-output playtable input)
  (define increment-data 0)
  (define (increment num)
    (set! increment-data (+ num increment-data))
    increment-data)

  (define (loop input)
    (if (null? input)
      '()
      (let ((event-data (caddar input))
            (abspos (increment (caar input))))
      (if (not (eq? 'note (cadr event-data)))
        (loop (cdr input))
        (let ((data (table-ref playtable
                               (list (cadar input)
                                     (caddr event-data))
                               #f)))
          (if (not data)
            (loop (cdr input))
            (append (list (list abspos
                                data
                                (car event-data)))
                    (loop (cdr input)))))))))
  (set! config-table playtable)
  (loop input))

(define (play output func)
  (define now (time->seconds (current-time)))
  (define (sleep divs)
    (set! now (+ now
                 (/ (* (/ divs divisions) tempo) 1000000)))
    (thread-sleep! (seconds->time now)))
  (define (loop pos output)
    (if (not (null? output))
      (begin
        (sleep (- (caar output) pos))
        (func (cadar output) (caddar output))
        (loop (caar output) (cdr output)))))
  (loop 0 output))

(define (output data type)
  (define (cmd data)
    (shell-command (string-append playcmd " " data)))
  (if (eq? type 'off)
    (cmd (table-ref config-table (list 17 0)))
    (cmd data)))

(define config-file "midiparser.config")
(define action 'play)
(define input-file "sow.mid")
(define playcmd "./play")
(define (parse-parameters par)
  (if (not (null? par))
    (if (eq? #\- (string-ref (car par) 0))
      (case (string->symbol (substring (car par) 1 (string-length (car par))))
        ('config (set! config-file (cadr par))
                 (parse-parameters (cddr par)))
        ('action (set! action (string->symbol (cadr par)))
                 (parse-parameters (cddr par)))
        ('help   (set! action 'help)
                 (parse-parameters (cdr par)))
        ('cmd    (set! playcmd (cadr par))
                 (parse-parameters (cddr par)))
        (else (display (list "Unrecognized parameter: \"" (car par) "\".\n"))
              (parse-parameters (cdr par))))
      (begin
        (set! input-file (car par))
        (parse-parameters (cdr par))))))
(parse-parameters (list "-action" "parse" "sow.mid"))
;(parse-parameters (list "-help"))
;(parse-parameters (cdr (command-line)))

(case action
  ('table  (table-for-each (lambda(k v) (write (list k v)) (newline))
                           (read-table config-file)))
  ('parse  (write input-file)
           (current-input-port (open-input-file input-file))
           (map (lambda(l) (write l) (newline))
                (midifile)))
  ('output (current-input-port (open-input-file input-file))
           (map (lambda(d) (write d) (newline))
                (make-output (read-table config-file) (midifile))))
  ('play   (current-input-port (open-input-file input-file))
           (play (make-output (read-table config-file) (midifile)) output))
  ('help   (display (list "Usage: " (car (command-line)) " [OPTIONS] [FILE]\n"
                          "Parses FILE depending on action parameter\n"
                          "FILE defaults to \"" input-file "\".\n\n"
                          "  -help          Display this help screen.\n"
                          "  -config CONF   Specify config table. Defaults to \"" config-file "\".\n"
                          "  -cmd CMD       Specify the player we should use. Defaults to \"" playcmd "\".\n"
                          "  -action ACT    What to do, could be one of the following:\n"
                          "          table       Output what is parsed from CONF.\n"
                          "          parse       Output what is parsed from FILE.\n"
                          "          output      Output what is going to be outputed to CMD, with time.\n"
                          "          play        Plays the file with CMD.\n"
                          "                 ACT defaults to \"" action "\".\n"
                          )))
  (else (display (list "Unrecongized action: \"" action "\".\n"
                       "Try " (car (command-line)) " -help\n"))))
(close-port (current-input-port))
